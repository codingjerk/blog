# Какой язык быстрее?

Недавно мне задали вопрос "а что быстрее, Rust или С?".
ChatGPT не ответил на этот вопрос достаточно подробно и
так появилась эта статья.

В качестве примера я буду рассматривать низкоуровневые языки:
вечные C, C++, модный Rust и совсем уж хипстерский Zig.

Теоретически, эти языки будут находиться по производительности
в одной категории, потому-что они:

- Компилируются в нативный машинный код
  <spoiler>
  Машинный код в общем случае выполняется быстрее, чем происходит интерпретация.
  Технически некоторый код, портированный 1 к 1 на язык с JIT-компиляцией,
  вроде Java, может быть быстрее нативного, но имея язык, компилируемый в машинный
  код всегда можно достичь аналогичной производительности, а обратное
  возможно не всегда.
  </spoiler>

- Предполагают ручной контроль над памятью, без сборщика мусора и автоматического подсчёта ссылок
  <spoiler>
  В противовес таким языкам, как Go или Swift – выделением и освобождением
  памяти нужно управлять самостоятельно. В некоторых задачах можно
  полностью избавиться от аллокаций памяти в куче, в остальных -
  контролировать то, как аллокации происходят.
  </spoiler>

- Поддерживают "абстракции с нулевой стоимостью"
  <spoiler>
  Также, часто упоминаемое правило C++ "вы не платите за то, что не используете",
  работает во всех рассматриваемых языках. В этих языках (почти) нет рантайма.
  Нет дополнительных уровней косвенности, если вы сами их не создаёте.
  Структуры не содержат информацию, которую вы сами явно не указываете.
  </spoiler>

- Являются низкоуровневыми
  <spoiler>
  Рассматриваемые языки максимально близки к современному железу,
  они предоставляют прямой доступ к аппаратным ресурсам и операционной
  системе.
  </spoiler>

На практике всё это означает, что при должном усердии можно добиться
одинаковой производительности (даже, одинакового генерируемого кода)
на почти любой задаче.

Однако, есть разница в том, сколько усилий нужно будет приложить,
и конечно, бывают исключения, которые мы и рассмотрим,
чтобы разобраться, как с точки зрения производительности
отличаются эти языки.

Итак, поехали разбираться.

## Оптимизирующие компиляторы

Если вы интересовались разработкой компиляторов, то знаете,
общие этапы через которые проходит исходный код, перед тем
как превратиться в машинный: лексический анализ (поток символов
превращается в поток отдельных "слов", токенов),
синтаксический анализ (из потока токенов строится дерево)
и кодогенерация (дерево превращается в машинный код).

В компиляторах рассматриваемых языков, есть отдельные стадии семантического анализа
(проверки/вывода типов). Из значимых для производительности отличий:

- У C и C++ есть несколько компиляторов: GCC, Clang, MSVC и ICC
  из популярных, обычно это означает возможность выбора,
  и больше возможностей для оптимизации. На разных задачах
  лидер в генерации оптимизированного кода может отличаться.

- Rust и Zig имеют одну эталонную реализацию компилятора,
  и оба для кодогенерации оптимизации используют бекенд LLVM,
  также как Clang.
  Они генерируют не машинный код, а т.н. LLVM IR. Это позволяет
  переложить задачи оптимизации и поддержку различных платформ на
  общий модуль.

- В отличие от Clang, компиляторы Rust и Zig перед генерацией LLVM IR
  выполняют генерацию промежуточного представления (MIR в компиляторе rustc
  и ZIR в zig) и применяют к нему специфичные для языка оптимизации
  в дополнение к оптимизациям, которые будут применяться LLVM.

Само по себе использование LLVM не гарантирует, что код получится быстрый,
многое будет зависеть от семантики языка – что конкретные языковые
конструкции будут означать с точки зрения стандарта.

Качество оптимизации будет зависеть в том числе и от того, сколько
усилий приложили к этому разработчики компилятора.

Над компиляторами C и C++ работают значительно дольше и больше,
ну и Zig с этой точки зрения должен проигрывать, т.к. в его
разработке учавствует значительно меньше людей.

Подытоживая, сложно выделить лидера, но, если субъективно упорядочить,
то, по этому пункту: `C == C++ >= Rust >= Zig`.

Теперь перейдём к значительным отличиям в языках, которые могут
повлиять на производительность.

## Поддержка метапрограммирования

Взгляните на этот код на C:

```c
void swap(char *a, char *b, size_t elem_size) {
    char temp[elem_size];
    memcpy(temp, a, elem_size);
    memcpy(a, b, elem_size);
    memcpy(b, temp, elem_size);
}

void sort(void *array, size_t size, size_t elem_size, int (*cmp)(const void*, const void*)) {
    char *ptr = array;
    
    for (size_t i = 0; i < size - 1; i++) {
        for (size_t j = 0; j < size - i - 1; j++) {
            if (cmp(ptr + j * elem_size, ptr + (j + 1) * elem_size) > 0) {
                swap(ptr + j * elem_size, ptr + (j + 1) * elem_size, elem_size);
            }
        }
    }
}
```

Это обобщённая реализация сортировки (не самая эффективная с алгоритмической
точки зрения), но суть именно в том, как реализуется обобщённость.

Мы можем использовать эту функцию на массивах любого типа, но
если бы мы писали вполне себе конкретную сортировку для массива
`int`, можно было бы обойтись таким кодом:

```c
void swapInt(int *a, int *b) {
    int temp = a;
    *a = *b;
    *b = temp;
}

void sortInt(int *array, size_t size, int (*cmp)(const int*, const int*)) {
    for (size_t i = 0; i < size - 1; i++) {
        for (size_t j = 0; j < size - i - 1; j++) {
            if (cmp(&array[j], &array[j + 1]) > 0) {
                swap(&array[j], &array[j + 1]);
            }
        }
    }
}
```

За счёт того, что мы знаем размер типа во время компиляции,
и размер в байтах небольшой, мы можем выполнять перестановку
элементов эффективнее – без вызовов `memcpy`.

Если написать разные реализации `sort` для разных типов, то можно
выиграть по производительности (в общем случае, в ущерб размеру исходного кода и бинарника).
На C это можно сделать как вручную, так и с помощью препроцессора
или кодогенерации.

Подобного рода задачи приходится решать настолько часто, что в
языках C++, Rust и Zig для этого есть свои инструменты.
Мы можем написать обобщённую версию функции, а затем
компилятор сам сгенерирует машинный код этой функции для
используемых типов.

В C++ код для обобщённой сортировки выглядел бы так:

```cpp
template <typename T>
void swap(T *a, T *b) {
    T temp = a;
    *a = *b;
    *b = temp;
}

template <typename T>
void sort(T *array, size_t size, int (*cmp)(const T*, const T*)) {
    for (size_t i = 0; i < size - 1; i++) {
        for (size_t j = 0; j < size - i - 1; j++) {
            if (cmp(&array[j], &array[j + 1]) > 0) {
                swap(&array[j], &array[j + 1]);
            }
        }
    }
}
```

Когда обобщённое программирование поддерживается на уровне языка,
писать более эффективный код проще. Также в стандартной библиотеке
обычно будут иметься обобщённые функции.

При желании можно сделать эту функцию определённой только для типов
с оператором сравнения и тогда нам не понадобится передавать
указатель на функцию `cmp`. Что, например, сделано в STL.

За счёт поддержки обобщённого программирования в C++, например,
`std::iostream` в C++ потенциально быстрее, чем `printf`,
а `std::sort` быстрее, чем `qsort`.

Понятное дело, что это даётся не бесплатно: больше время компиляции,
выше сложность языка, больше размер бинарного файла и конечно,
не в каждом случае специализированные функции будут быстрее.
При оптимизации конкретных программ, нужны будут конкретные, а не
общие решения.

Но в _общем случае_, поддержка обобщённого программирования позволяет писать
более эффективные программы.

Rust, как и C++ поддерживает обобщенное программирование,
с немного отличным от C++ синтаксисом и семантикой,
но похожим результатом:

<spoiler>
Для упрощения кода, пришлось немного изменить сигнатуру функции
`swap`, т.к. в Rust проблематично взять две мутабельные ссылки
на один объект.

Также это не самый идеоматичный Rust код, но он максимально приближен
к исходному на C++.
</spolier>

```rust
pub fn swap<T: Copy>(array: &mut [T], a: usize, b: usize) {
    let temp = array[a];
    array[a] = array[b];
    array[b] = temp;
}

pub fn sort<T: Copy>(array: &mut [T], cmp: fn(&T, &T) -> i32) {
    let size = array.len();

    for i in 0..size {
        for j in 0..size - i - 1 {
            if cmp(&array[j], &array[j + 1]) > 0 {
                swap(array, j, j + 1);
            }
        }
    }
}
```

В Rust поддержка обобщённого программирования этим не заканчивается,
в языке есть очень мощные макросы, позволяющие безопасно генерировать
код, расширять синтаксис языка, выполнять вычисления на этапе
компиляции (при этом проще, чем используя шаблонную магию в C++).

В Zig реализация обобщённого программирования отличается, процедурные
макросы и generic'и объединены там в одну сущность: `comptime`.
Пример функции `sort` для Zig:

```zig
const std = @import("std");

fn swap(comptime T: type, a: *T, b: *T) void {
    var temp: T = a.*;
    a.* = b.*;
    b.* = temp;
}

fn sort(comptime T: type, array: []T, cmp: fn(a: *const T, b: *const T) i32) void {
    const size = array.len;

    for (array) |a, i| {
        for (array[0..size - i - 1]) |b, j| {
            if (cmp(a, b) == std.Order.GT) {
                swap(&a, &b);
            }
        }
    }
}
```

Ключевое слово `comptime` в данном примере не обязательно, но
подразумевается. Если указать его явно, компилятор всегда будет
вычислять такой аргумент во время компиляции.

Типы только так и можно вычислить, но это может быть полезно
для константных значений в качестве обобщённых параметров.

На основе `comptime` реализованы и обобщённые структуры данных –
они на самом деле просто функции, которые возвращают конкретный
тип и могут быть вычислены только во время компиляции (т.к.
язык статически типизирован).

Несмотря на отличие в семантике и синтаксисе, поддержка обобщённого
программирования во всех языках, кроме C на достаточно
высоком уровне.

В теории вы можете использовать приёмы обобщённого программирования
и используя C, с помощью, например, кодогенерации, но на практике,
куда проще взять другой язык.

## Неопределённое поведение

TODO
